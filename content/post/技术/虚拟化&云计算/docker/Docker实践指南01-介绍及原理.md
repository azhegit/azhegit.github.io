---
categories:
- 技术
- 虚拟化&云计算
date: 2018-11-02 13:30:51+08:00
tags:
- docker
thumbnailImage: //www.azheimage.top/markdown-img-paste-20181113164516536.png
title: Docker实践指南01-介绍及原理
---

Docker实践指南01-介绍及原理
<!--more-->
<!-- [toc] -->
## Docker介绍及原理
![](https://www.azheimage.top/markdown-img-paste-20181101182650845.png)
### docker简介
>* Docker基于容器技术的轻量级虚拟化解决方案
>* Docker是一个开源的应用容器引擎，把Linux的cgroup、namespace等容器底层技术进行封装抽象，为用户提供了创建和管理容器的便捷界面（包括命令行和API）,让开发者可以打包应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上
>* Docker 是一个开源项目,加入了 Linux 基金会，遵从Apache 2.0 协议，原始码在GitHub上进行维护，诞生于 2013 年初，基于 Google 公司推出的 Go 语言实现,Go 语言实作，
>* 在 LXC 的基础上Docker进行了进一步的封装，让使用者不需要去关心容器的管理，使得操作更为简便。使用者操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单

### Docker的应用场景
>Docker可以快速创建和删除容器，实现快速迭代，大量节约开发、测试、部署的时间。并且，各个步骤都有明确的配置和操作，整个过程全程可见，使团队更容易理解应用的创建和工作过程

* 开发、测试：
  以docker为单位的开发测试部署流程,简化了环境搭建的步骤,提高了资源利用效率和开发测试部署的速度,降低了迁移的成本
* 交付、部署：
  更快速的交付和部署。使用Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用相同环境来部署代码。


### 传统虚拟机的弊端：
1、资源利用效率低
2、单物理机多应用无法有效隔离（进程空间，cpu资源，磁盘）
3、运维部署不便
4、测试、版本管理复杂
5、迁移成本高
6、传统虚拟机，空间占用大，启动慢，管理复杂

### Docker VS VM 区别
![](https://www.azheimage.top/markdown-img-paste-20181101195529985.png)
* 虚拟机的Guest OS层和Hypervisor层在docker中被Docker Engine层所替代。虚拟机的Guest OS即为虚拟机安装的操作系统，它是一个完整操作系统内核；虚拟机的Hypervisor层可以简单理解为一个硬件虚拟化平台，它在Host OS是以内核态的驱动存在的。 
* docker并没有和虚拟机一样利用一个完全独立的Guest OS实现环境隔离，它利用的是目前Linux内核本身支持的容器方式实现资源和环境隔离。简单的说，docker利用namespace实现系统环境的隔离；利用Cgroup实现资源限制；利用镜像实现根目录环境的隔离。

||Docker|虚拟机|
|-|-|-|
|启动速度|秒级|分钟级|
|复杂度|基于内核的namespace技术，对现有基础设施的侵入较少|部署复杂度较高，并且很多基础设施不兼容
|执行性能|在内核中实现，所以性能几乎与原生一致|对比内核级实现，性能较差
|可控性|依赖简单，与进程无本质区别|依赖复杂，并且存在跨部门问题
|体积|与业务代码发布版本大小相当MB级别|GB级别
|并发性|可以启动几百几千个容器|最多几十个虚拟机
|资源利用率|高|低
### Docker优势
* **更快速的交付和部署**
对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。
* **更高效的虚拟化**
Docker 容器的运行不需要额外的 hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。
* **更轻松的迁移和扩展**
Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。
* **更简单的管理**
使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。

### 什么是docker？
![](https://www.azheimage.top/markdown-img-paste-20181101201615106.png)
#### 1. 镜像（images）
##### Docker 镜像就是一个只读的模板，比虚拟机是更轻量,镜像可以用来创建容器
>例如：一个镜像可以包含一个完整的 Linux 操作系统环境，里面仅安装了 Tomcat或用户需要的其它应用程序

![](https://www.azheimage.top/markdown-img-paste-20181101204442450.png)
Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。
#### 2. 容器（containers）
##### Docker 利用容器来运行应用。
容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。
![](https://www.azheimage.top/markdown-img-paste-20181101205332287.png)
可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。

#### 3. 仓库（repository）
##### 仓库是集中存放镜像文件的场所
仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签
仓库分为公开仓库（Public）和私有仓库（Private）两种形式
push 镜像到仓库,从仓库pull下镜像
最大的公开仓库是[Docker Hub](https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括[网易云镜像](https://c.163yun.com/hub#/m/home/)，[阿里云镜像](https://dev.aliyun.com/list.html)等，可以提供大陆用户更稳定快速的访问，或者用[阿里云加速](https://cr.console.aliyun.com/cn-qingdao/mirrors)。
Mac配置阿里加速Docker：
![](https://www.azheimage.top/markdown-img-paste-20181101203306622.png)

#### 4. 层级（layers）
##### 镜像（images）与层级（layers）
Docker 镜像是由多个文件系统（只读层）叠加而成，每个层仅包含了前一层的差异部分。当我们启动一个容器的时候，Docker 会加载镜像层并在其上添加一个可写层。容器上所做的任何更改，譬如新建文件、更改文件、删除文件，都将记录与可写层上。容器层与镜像层的结构如下图所示
![](https://www.azheimage.top/markdown-img-paste-20181101203759818.png)
##### 容器（container）与层级（layers）：
容器与镜像最大的区别就在于可写层上。如果运行中的容器修改了现有的一个已存在的文件，那该文件将会从可写层下的只读层复制到可写层，该文件的只读版本仍然存在，只是已经被可写层中该文件的副本所隐藏。其中。多个容器共享镜像的结构如下所示
![](https://www.azheimage.top/markdown-img-paste-20181101203909561.png)

###### 只读层及在顶部的读写层的组合被Docker称为 Union File System（联合文件系统）
![](https://www.azheimage.top/markdown-img-paste-20181101204941686.png)

#### 5. 链接(links)
容器的连接（linking）系统是除了端口映射外，另一种跟容器中应用交互的方式。
在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息。
Docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主主机上。从而避免了暴露关键系统（如数据库）端口到外部网络上。
![](https://www.azheimage.top/markdown-img-paste-20181101205801396.png)
